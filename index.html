<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ACE – ZIP Validator + Viewer (Gates 0–4 + Verified + XML + OCR) v8</title>

  <style>
    :root{
      --bg:#0b0f14; --panel:#111827; --muted:#94a3b8; --text:#e5e7eb;
      --line:#1f2937; --btn:#2563eb; --btn2:#334155;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .wrap{ padding:18px; }
    .grid{ display:flex; gap:14px; align-items:stretch; flex-wrap:wrap; }
    .panel{
      flex:1;
      background:linear-gradient(180deg, rgba(17,24,39,.92), rgba(15,23,42,.92));
      border:1px solid var(--line);
      border-radius:14px;
      padding:14px;
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
      min-height: 560px;
      overflow:hidden;
    }
    .panel.small{ flex:0.95; min-width: 320px; }
    .panel.viewer{ flex:1.4; min-width: 420px; }
    .panel.results{ flex:1.05; min-width: 360px; }

    h2{ margin:0 0 10px; font-weight:820; letter-spacing:.2px; }
    h3{ margin:14px 0 8px; font-weight:740; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    input[type="file"]{
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      padding:10px;
      border-radius:10px;
      color:var(--text);
      max-width:100%;
    }
    button{
      background:var(--btn);
      color:white;
      border:none;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
      font-weight:820;
    }
    button.secondary{ background:var(--btn2); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .muted{ color:var(--muted); font-size:13px; line-height:1.4; }
    ul{ margin:8px 0 0; padding-left:18px; }
    li{ margin:6px 0; color:#cbd5e1; word-break:break-word; }

    pre{
      background:rgba(2,6,23,.78);
      border:1px solid rgba(148,163,184,.18);
      padding:12px;
      border-radius:12px;
      overflow:auto;
      max-height: 260px;
      line-height:1.45;
      white-space:pre-wrap;
    }

    .tabs{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .tab{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(148,163,184,.18);
      color:var(--text);
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:820;
      font-size:13px;
      user-select:none;
    }
    .tab.active{
      background:rgba(37,99,235,.22);
      border-color:rgba(37,99,235,.55);
    }

    .viewbox{
      margin-top:10px;
      border:1px solid rgba(148,163,184,.18);
      border-radius:12px;
      background:rgba(2,6,23,.55);
      height: 610px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .viewbar{
      padding:8px 10px;
      border-bottom:1px solid rgba(148,163,184,.18);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .left{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pill{
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.22);
      color:#cbd5e1;
      font-size:12px;
      background:rgba(255,255,255,.04);
    }

    .linkbtn{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(148,163,184,.2);
      padding:6px 10px;
      border-radius:10px;
      font-weight:840;
      color:#e5e7eb;
      cursor:pointer;
    }

    .pdfWrap{ flex:1; display:none; overflow:auto; padding:10px; }
    canvas{ max-width:100%; height:auto; border-radius:8px; background:white; }

    .pdfControls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pdfControls button{ padding:6px 10px; border-radius:10px; font-weight:840; }
    .pdfControls .mini{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(148,163,184,.2);
      color:#e5e7eb;
    }
    iframe{ width:100%; height:100%; border:0; background:white; display:none; }
    .textpane{
      flex:1;
      overflow:auto;
      padding:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      white-space:pre-wrap;
      color:#e5e7eb;
      display:none;
    }
    .hint{ color:#94a3b8; font-size:12px; margin-top:8px; }

    /* Gate Cards */
    #gateCards{ display:flex; flex-direction:column; gap:10px; margin-top:10px; }
    .gateCard{
      border:1px solid rgba(148,163,184,.18);
      background:rgba(2,6,23,.55);
      border-radius:14px;
      padding:12px;
    }
    .gateTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .gateName{ font-weight:900; }
    .badge{
      padding:4px 10px; border-radius:999px; font-weight:900; font-size:12px;
      border:1px solid rgba(148,163,184,.22);
    }
    .badge.pass{ background:rgba(34,197,94,.18); border-color:rgba(34,197,94,.5); }
    .badge.warn{ background:rgba(245,158,11,.18); border-color:rgba(245,158,11,.55); }
    .badge.fail{ background:rgba(239,68,68,.18); border-color:rgba(239,68,68,.55); }
    .gateBody{ margin-top:8px; color:#cbd5e1; font-size:13px; line-height:1.55; white-space:pre-wrap; }
    .gateVerified{
      margin-top:10px;
      padding:8px 10px;
      border-radius:12px;
      background:rgba(37,99,235,.14);
      border:1px solid rgba(37,99,235,.35);
      font-weight:850;
    }

    /* Verified Info Table */
    .tableWrap{
      border:1px solid rgba(148,163,184,.18);
      background:rgba(2,6,23,.55);
      border-radius:14px;
      overflow:hidden;
    }
    .vTable{ width:100%; border-collapse:collapse; font-size:13px; }
    .vTable th, .vTable td{
      padding:10px 10px;
      border-bottom:1px solid rgba(148,163,184,.14);
      vertical-align:top;
    }
    .vTable th{
      width:170px;
      text-align:left;
      color:#cbd5e1;
      font-weight:900;
      background:rgba(255,255,255,.03);
    }
    .vTable td{ color:#e5e7eb; }
    .kpill{
      display:inline-block;
      padding:4px 10px;
      margin:4px 6px 0 0;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.22);
      background:rgba(255,255,255,.05);
      font-size:12px;
      color:#e5e7eb;
    }
    .smallNote{ color:#94a3b8; font-size:12px; margin-top:6px; }

    /* Small toggles */
    label.tog { display:flex; align-items:center; gap:8px; font-size:13px; color:#cbd5e1; }
    input[type="checkbox"]{ transform: scale(1.2); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="grid">

      <div class="panel small">
        <h2>Upload ZIP</h2>
        <div class="row">
          <input type="file" id="zipInput" accept=".zip" />
          <button id="runBtn" onclick="runPipeline()">Run</button>
          <button class="secondary" onclick="resetUI()">Reset</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <label class="tog">
            <input type="checkbox" id="forceOcr" />
            Force OCR (always)
          </label>
          <label class="tog">
            OCR pages:
            <input type="number" id="ocrPages" value="3" min="1" max="6" style="width:64px; padding:6px; border-radius:8px; border:1px solid var(--line); background:rgba(255,255,255,.06); color:var(--text);" />
          </label>
        </div>

        <div class="muted" style="margin-top:10px;">
          ZIP should contain: <b>PDF</b>, <b>HTML</b>, <b>_Api.xml</b>, <b>_Scrapping.xml</b>
        </div>

        <h3>Files detected</h3>
        <ul id="fileList"></ul>

        <h3 style="margin-top:16px;">Viewer status</h3>
        <div class="muted" id="viewerStatus">Upload a ZIP to preview support docs.</div>
      </div>

      <div class="panel viewer">
        <h2>Support Docs Viewer</h2>

        <div class="tabs">
          <div class="tab active" data-tab="pdf" onclick="switchTab('pdf')">PDF (PDF.js)</div>
          <div class="tab" data-tab="html" onclick="switchTab('html')">HTML Summary</div>
          <div class="tab" data-tab="api" onclick="switchTab('api')">API XML</div>
          <div class="tab" data-tab="scrape" onclick="switchTab('scrape')">Scrape XML</div>
        </div>

        <div class="viewbox">
          <div class="viewbar">
            <div class="left">
              <span class="pill" id="docName">No file loaded</span>
              <span class="pill" id="docMeta">—</span>
              <span class="pill" id="pdfMeta" style="display:none;">Page — / —</span>
            </div>

            <div class="pdfControls" id="pdfControls" style="display:none;">
              <button class="mini" onclick="pdfPrev()">Prev</button>
              <button class="mini" onclick="pdfNext()">Next</button>
              <button class="mini" onclick="pdfZoomOut()">-</button>
              <button class="mini" onclick="pdfZoomIn()">+</button>
              <button class="linkbtn" onclick="downloadCurrent()" id="downloadBtn" disabled>Download</button>
              <button class="linkbtn" onclick="openPdfNewTab()" id="openPdfBtn" disabled>Open PDF</button>
            </div>

            <div class="right" id="nonPdfControls">
              <button class="linkbtn" onclick="downloadCurrent()" id="downloadBtn2" disabled>Download</button>
            </div>
          </div>

          <div class="pdfWrap" id="pdfWrap">
            <canvas id="pdfCanvas"></canvas>
          </div>

          <iframe id="htmlFrame" sandbox="allow-same-origin"></iframe>

          <div id="apiPane" class="textpane"></div>
          <div id="scrapePane" class="textpane"></div>
        </div>

        <div class="hint">
          Gate 0.5 is STRICT: PDF trusted only if readable text exists OR OCR finds arXiv ID on pages 1–N.
          Keywords are captured ONLY from a short “Keywords:” line (prevents grabbing the introduction).
        </div>
      </div>

      <div class="panel results">
        <h2>Gate Results</h2>
        <div id="gateCards"></div>

        <h2 style="margin-top:14px;">Verified Info</h2>
        <div id="verifiedWrap" style="margin-top:10px;"></div>

        <div class="row" style="margin-top:10px; gap:10px;">
          <button id="genXmlBtn" onclick="generateXML()" disabled>Generate XML</button>
          <button class="secondary" id="valXmlBtn" onclick="validateXML()" disabled>Validate XML (later)</button>
        </div>

        <div class="muted" id="verifiedHint" style="margin-top:8px;">
          If PDF is image-only, OCR is used for Gate 0.5 + arXiv detection + abstract/keywords (best-effort).
        </div>

        <h2 style="margin-top:12px;">Raw Log</h2>
        <pre id="output">Waiting for ZIP…</pre>
      </div>

    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    const state = {
      zip: null,
      files: { pdf:null, html:null, api:null, scrape:null },
      blobs: { pdfBytes:null, htmlUrl:null, apiText:"", scrapeText:"" },
      currentTab: "pdf",
      pdfDoc: null,
      pdfPage: 1,
      pdfScale: 1.25,
      rendering: false,
      htmlText: "",
      pdfObjectUrl: null
    };

    const verified = {
      arxivId: null,
      version: null,
      confirmed: false,
      title: null,
      abstract: null,
      keywords: [],
      authors: [],
      affiliations: [],
      notes: [],
      sources: {}
    };

    // ===== OCR worker (reused) =====
    let OCR_WORKER = null;
    async function getOcrWorker(){
      if (OCR_WORKER) return OCR_WORKER;
      OCR_WORKER = await Tesseract.createWorker("eng");
      // Speed/accuracy tweaks (we mostly need arXiv tokens + text blocks)
      try{
        await OCR_WORKER.setParameters({
          preserve_interword_spaces: "1",
        });
      } catch(e){}
      return OCR_WORKER;
    }

    function $(id){ return document.getElementById(id); }
    function cleanSpaces(s){ return (s||"").replace(/\s+/g," ").trim(); }

    function escapeHtml(s){
      return (s ?? "").toString()
        .replace(/&/g,"&amp;").replace(/</g,"&lt;")
        .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
        .replace(/'/g,"&apos;");
    }
    function escapeXml(s){ return escapeHtml(s); }

    function appendLog(line){
      const out = $("output");
      out.textContent += (out.textContent.endsWith("\n") ? "" : "\n") + line + "\n";
    }

    function resetGateCards(){ $("gateCards").innerHTML = ""; }
    function addGateCard({ name, status, bodyLines=[], verifiedLine=null }){
      const box = $("gateCards");
      const card = document.createElement("div");
      card.className = "gateCard";

      const badgeClass = status === "PASS" ? "pass" : status === "WARN" ? "warn" : "fail";
      const badgeText = status === "PASS" ? "PASSED" : status === "WARN" ? "WARN" : "FAILED";

      card.innerHTML = `
        <div class="gateTop">
          <div class="gateName">${escapeHtml(name)}</div>
          <div class="badge ${badgeClass}">${badgeText}</div>
        </div>
        <div class="gateBody">${escapeHtml(bodyLines.join("\n"))}</div>
        ${verifiedLine ? `<div class="gateVerified">${escapeHtml(verifiedLine)}</div>` : ""}
      `;
      box.appendChild(card);
    }

    function setVerified(patch){
      Object.assign(verified, patch);
      renderVerifiedInfo();
    }

    function renderVerifiedInfo(){
      const wrap = $("verifiedWrap");
      const idv = verified.arxivId ? `arXiv:${verified.arxivId}${verified.version || ""}` : "—";
      const status = verified.confirmed ? "✅ CONFIRMED" : "⚠ NOT CONFIRMED";

      const kws = verified.keywords || [];
      const authors = verified.authors || [];
      const affs = verified.affiliations || [];

      const kwsHtml = kws.length
        ? kws.map(k => `<span class="kpill">${escapeHtml(k)}</span>`).join("")
        : `<span class="muted">—</span>`;

      const authHtml = authors.length
        ? `<ol style="margin:0; padding-left:18px;">${authors.map(a=>`<li>${escapeHtml(a)}</li>`).join("")}</ol>`
        : `<span class="muted">—</span>`;

      const affHtml = affs.length
        ? `<ol style="margin:0; padding-left:18px;">${affs.map(a=>`<li>${escapeHtml(a)}</li>`).join("")}</ol>`
        : `<span class="muted">—</span>`;

      const noteHtml = verified.notes?.length
        ? `<div class="smallNote">${verified.notes.map(n=>`• ${escapeHtml(n)}`).join("<br/>")}</div>`
        : "";

      wrap.innerHTML = `
        <div class="tableWrap">
          <table class="vTable">
            <tr><th>Status</th><td>${status}</td></tr>
            <tr><th>arXiv</th><td><b>${escapeHtml(idv)}</b>${noteHtml}</td></tr>
            <tr><th>Title</th><td>${verified.title ? escapeHtml(verified.title) : "<span class='muted'>—</span>"}</td></tr>
            <tr><th>Abstract</th><td>${verified.abstract ? escapeHtml(verified.abstract) : "<span class='muted'>—</span>"}</td></tr>
            <tr><th>Keywords</th><td>${kwsHtml}</td></tr>
            <tr><th>Authors</th><td>${authHtml}</td></tr>
            <tr><th>Affiliations</th><td>${affHtml}</td></tr>
          </table>
        </div>
      `;

      const canGenerate = !!verified.arxivId && !!verified.confirmed;
      $("genXmlBtn").disabled = !canGenerate;
      $("valXmlBtn").disabled = !canGenerate;
    }

    function cleanupBlobUrls(){
      try{ if(state.blobs.htmlUrl) URL.revokeObjectURL(state.blobs.htmlUrl); }catch(e){}
      try{ if(state.pdfObjectUrl) URL.revokeObjectURL(state.pdfObjectUrl); }catch(e){}
      state.pdfObjectUrl = null;
    }

    function resetUI(){
      $("fileList").innerHTML = "";
      $("output").textContent = "Waiting for ZIP…";
      $("zipInput").value = "";
      $("viewerStatus").textContent = "Upload a ZIP to preview support docs.";
      resetGateCards();

      cleanupBlobUrls();
      state.zip = null;
      state.files = { pdf:null, html:null, api:null, scrape:null };
      state.blobs = { pdfBytes:null, htmlUrl:null, apiText:"", scrapeText:"" };
      state.htmlText = "";

      state.currentTab = "pdf";
      state.pdfDoc = null;
      state.pdfPage = 1;
      state.pdfScale = 1.25;

      $("htmlFrame").src = "about:blank";
      $("apiPane").textContent = "";
      $("scrapePane").textContent = "";

      const ctx = $("pdfCanvas").getContext("2d");
      if (ctx) ctx.clearRect(0,0,$("pdfCanvas").width,$("pdfCanvas").height);

      $("docName").textContent = "No file loaded";
      $("docMeta").textContent = "—";
      $("pdfMeta").style.display = "none";

      $("downloadBtn").disabled = true;
      $("downloadBtn2").disabled = true;
      $("openPdfBtn").disabled = true;

      Object.assign(verified, {
        arxivId:null, version:null, confirmed:false, title:null, abstract:null,
        keywords:[], authors:[], affiliations:[], notes:[], sources:{}
      });
      renderVerifiedInfo();

      switchTab("pdf");
    }

    function findFile(zip, pattern) {
      const name = Object.keys(zip.files).find(f => pattern.test(f));
      return name ? zip.files[name] : null;
    }

    function switchTab(tab){
      state.currentTab = tab;
      Array.from(document.querySelectorAll(".tab"))
        .forEach(t => t.classList.toggle("active", t.dataset.tab === tab));

      $("pdfWrap").style.display = "none";
      $("htmlFrame").style.display = "none";
      $("apiPane").style.display = "none";
      $("scrapePane").style.display = "none";

      const hasZip = !!state.zip;
      $("downloadBtn").disabled = !hasZip;
      $("downloadBtn2").disabled = !hasZip;
      $("openPdfBtn").disabled = !hasZip || !state.blobs.pdfBytes;

      const isPdf = tab === "pdf";
      $("pdfControls").style.display = isPdf ? "flex" : "none";
      $("nonPdfControls").style.display = isPdf ? "none" : "block";
      $("pdfMeta").style.display = isPdf ? "inline-block" : "none";

      if(tab === "pdf"){
        $("docName").textContent = "PDF";
        $("docMeta").textContent = state.files.pdf ? "loaded" : "missing";
        $("pdfWrap").style.display = "block";
        if (state.pdfDoc) renderPdfPage();
      } else if(tab === "html"){
        $("docName").textContent = "HTML Summary";
        $("docMeta").textContent = state.files.html ? "loaded" : "missing";
        $("htmlFrame").style.display = "block";
      } else if(tab === "api"){
        $("docName").textContent = "API XML";
        $("docMeta").textContent = state.files.api ? "loaded" : "missing";
        $("apiPane").style.display = "block";
      } else if(tab === "scrape"){
        $("docName").textContent = "Scrape XML";
        $("docMeta").textContent = state.files.scrape ? "loaded" : "missing";
        $("scrapePane").style.display = "block";
      }
    }

    // ===== PDF.js load/render (with worker fallback) =====
    function configurePdfWorker(){
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    }

    async function loadPdfViewer(pdfBytes){
      configurePdfWorker();
      try{
        const task = pdfjsLib.getDocument({ data: pdfBytes });
        state.pdfDoc = await task.promise;
      } catch(e){
        appendLog("⚠ PDF.js worker failed, retrying without worker...");
        try{
          pdfjsLib.disableWorker = true;
          const task2 = pdfjsLib.getDocument({ data: pdfBytes });
          state.pdfDoc = await task2.promise;
        } catch(e2){
          throw e2;
        }
      }
      state.pdfPage = 1;
      state.pdfScale = 1.25;
      updatePdfMeta();
      await renderPdfPage();
    }

    function updatePdfMeta(){
      if (!state.pdfDoc) { $("pdfMeta").textContent = "Page — / —"; return; }
      $("pdfMeta").textContent = `Page ${state.pdfPage} / ${state.pdfDoc.numPages}  |  Zoom ${Math.round(state.pdfScale*100)}%`;
    }

    async function renderPdfPage(){
      if (!state.pdfDoc || state.rendering) return;
      state.rendering = true;
      try{
        updatePdfMeta();
        const page = await state.pdfDoc.getPage(state.pdfPage);
        const viewport = page.getViewport({ scale: state.pdfScale });

        const canvas = $("pdfCanvas");
        const ctx = canvas.getContext("2d");

        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);

        await page.render({ canvasContext: ctx, viewport }).promise;
      } finally {
        state.rendering = false;
      }
    }

    function pdfPrev(){ if (!state.pdfDoc) return; state.pdfPage = Math.max(1, state.pdfPage - 1); renderPdfPage(); }
    function pdfNext(){ if (!state.pdfDoc) return; state.pdfPage = Math.min(state.pdfDoc.numPages, state.pdfPage + 1); renderPdfPage(); }
    function pdfZoomIn(){ if (!state.pdfDoc) return; state.pdfScale = Math.min(3.0, state.pdfScale + 0.15); renderPdfPage(); }
    function pdfZoomOut(){ if (!state.pdfDoc) return; state.pdfScale = Math.max(0.6, state.pdfScale - 0.15); renderPdfPage(); }

    function openPdfNewTab(){
      if(!state.blobs.pdfBytes) return;
      if(state.pdfObjectUrl) URL.revokeObjectURL(state.pdfObjectUrl);
      const blob = new Blob([state.blobs.pdfBytes], { type:"application/pdf" });
      state.pdfObjectUrl = URL.createObjectURL(blob);
      window.open(state.pdfObjectUrl, "_blank", "noopener,noreferrer");
    }

    function downloadCurrent(){
      if(!state.zip) return;

      let blob = null;
      let filename = "download.txt";

      if(state.currentTab === "pdf"){
        blob = new Blob([state.blobs.pdfBytes], { type:"application/pdf" });
        filename = "support.pdf";
      } else if(state.currentTab === "html"){
        blob = new Blob([state.htmlText || ""], { type:"text/html;charset=utf-8" });
        filename = "summary.html";
      } else if(state.currentTab === "api"){
        blob = new Blob([state.blobs.apiText || ""], { type:"application/xml" });
        filename = "api.xml";
      } else if(state.currentTab === "scrape"){
        blob = new Blob([state.blobs.scrapeText || ""], { type:"application/xml" });
        filename = "scrape.xml";
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 500);
    }

    // ===== Better PDF text extraction (keeps line breaks using y buckets) =====
    async function extractPdfTextStructured(pdfBytes, maxPages=3){
      configurePdfWorker();
      const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
      const pdf = await loadingTask.promise;

      let all = "";
      const pagesToRead = Math.min(maxPages, pdf.numPages);

      for (let p = 1; p <= pagesToRead; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        // items: {str, transform} transform[5] ~ y
        const lines = new Map();
        for (const it of content.items){
          const s = (it.str || "").trim();
          if (!s) continue;
          const y = it.transform ? Math.round(it.transform[5]) : 0;
          const key = String(y);
          if (!lines.has(key)) lines.set(key, []);
          lines.get(key).push(s);
        }
        const ys = [...lines.keys()].map(k=>parseInt(k,10)).sort((a,b)=>b-a);
        const pageText = ys.map(y => lines.get(String(y)).join(" ")).join("\n");
        all += `\n\n===PAGE ${p}===\n` + pageText;
      }
      return all;
    }

    function assessPdfReadability(pdfText) {
      const t = cleanSpaces(pdfText || "");
      const charCount = t.length;
      const words = t ? t.split(/\s+/).filter(Boolean) : [];
      const wordCount = words.length;

      const letters = t.replace(/[^A-Za-z]/g, "");
      const uniqueChars = new Set(letters.split("")).size;
      const uniqueCharRatio = letters.length ? uniqueChars / letters.length : 0;

      // Better: many good PDFs have fewer chars on first pages; still treat as readable if solid words exist.
      const readable = (charCount >= 250 && wordCount >= 50) || (charCount >= 650);
      const looksGarbage = letters.length > 120 && uniqueCharRatio < 0.03;

      return {
        readable: readable && !looksGarbage,
        charCount,
        wordCount,
        uniqueCharRatio: Number(uniqueCharRatio.toFixed(4)),
        looksGarbage
      };
    }

    // ===== arXiv extraction =====
    function extractArxivIdFromText(t) {
      const m = (t || "").match(/(?:arXiv\s*:\s*)?(\d{4}\.\d{5})(?:v(\d+))?/i);
      if (!m) return null;
      return { id: m[1], version: m[2] ? `v${m[2]}` : null };
    }

    function extractVersionFromScrapeXml(xmlText) {
      const idMatch = (xmlText || "").match(/<item[^>]*\bid="(\d{4}\.\d{5})"/i);
      const vMatch  = (xmlText || "").match(/<version[^>]*\bnumber="\[v(\d+)\]"/i);
      return { id: idMatch ? idMatch[1] : null, version: vMatch ? `v${vMatch[1]}` : null };
    }

    function extractFromApiXml(apiText) {
      const absId = (apiText || "").match(/arxiv\.org\/abs\/(\d{4}\.\d{5})(?:v(\d+))?/i);
      if (absId) return { id: absId[1], version: absId[2] ? `v${absId[2]}` : null };

      const oai = (apiText || "").match(/oai:arXiv\.org:(\d{4}\.\d{5})/i);
      if (oai) return { id: oai[1], version: null };

      const idOnly = (apiText || "").match(/(\d{4}\.\d{5})(?:v(\d+))?/i);
      return idOnly ? { id:idOnly[1], version: idOnly[2] ? `v${idOnly[2]}` : null } : { id:null, version:null };
    }

    function extractFromHtml(html) {
      const id = ((html || "").match(/(\d{4}\.\d{5})/i) || [null, null])[1];
      // arXiv HTML sometimes shows versions like (v1), (v2) etc
      const all = [...(html || "").matchAll(/\(v(\d+)\)/gi)];
      const maxV = all.length ? Math.max(...all.map(m => parseInt(m[1], 10))) : null;
      return { id: id || null, version: maxV ? `v${maxV}` : null };
    }

    // ===== STRICT Gate 1 logic (comprehensive) =====
    function gate1Confirm({ pdf, html, scrape, api, pdfTrusted }) {
      const problems = [];
      const warnings = [];
      const notes = [];

      const sources = [
        {src:"PDF", id: pdf?.id || null, v: pdf?.version || null},
        {src:"API", id: api?.id || null, v: api?.version || null},
        {src:"HTML", id: html?.id || null, v: html?.version || null},
        {src:"Scrape", id: scrape?.id || null, v: scrape?.version || null},
      ];

      const presentIds = sources.filter(s => s.id);
      if (!presentIds.length) {
        problems.push("No arXiv ID found in any source.");
        return { ok:false, problems, warnings, notes, chosenId:null, chosenV:null, mode:"none" };
      }

      // ID must match across ALL sources that have an ID
      const id0 = presentIds[0].id;
      const idMismatch = presentIds.some(s => s.id !== id0);
      if (idMismatch){
        problems.push("ID mismatch across sources (all IDs must match).");
      }

      // Version: if any version exists, ALL versions that exist must match
      const presentV = sources.filter(s => s.v);
      let vChosen = null;
      if (presentV.length){
        vChosen = presentV[0].v;
        const vMismatch = presentV.some(s => s.v !== vChosen);
        if (vMismatch){
          problems.push("Version mismatch across sources that report a version.");
        }
        // warn on missing versions
        for (const s of sources){
          if (!s.v) warnings.push(`${s.src} version missing (cannot fully confirm from that source).`);
        }
      } else {
        warnings.push("No version found in any source (will output without version unless scrape/html provides later).");
      }

      const mode = (pdfTrusted && pdf?.id) ? "PDF-authoritative (trusted)" : "Fallback (PDF untrusted)";
      if (!pdfTrusted) notes.push("PDF not trusted → still requiring cross-source ID/version agreement from HTML/Scrape/API.");

      // Choose ID/version (only if no mismatch)
      const chosenId = id0;
      const chosenV = vChosen;

      return { ok: problems.length===0, problems, warnings, notes, chosenId, chosenV, mode };
    }

    // ===== Title rules =====
    function extractTitleFromHtml(htmlText) {
      const metaOg = (htmlText || "").match(/<meta[^>]+property=["']og:title["'][^>]+content=["']([^"']+)["']/i);
      if (metaOg) return cleanSpaces(metaOg[1]);

      const metaTitle = (htmlText || "").match(/<meta[^>]+name=["']citation_title["'][^>]+content=["']([^"']+)["']/i);
      if (metaTitle) return cleanSpaces(metaTitle[1]);

      const titleTag = (htmlText || "").match(/<title[^>]*>(.*?)<\/title>/is);
      if (titleTag) return cleanSpaces(titleTag[1]);

      return null;
    }

    function normalizeTitleForCompare(t) {
      if (!t) return "";
      let s = cleanSpaces(t);

      s = s.replace(/\((?:\s*(?:preprint|extended abstract)\s*)\)/ig, "");
      s = s.replace(/\b(?:preprint|extended abstract)\b/ig, "");

      s = s.replace(/\$/g, "");
      s = s.replace(/\\times/gi, "×");
      s = s.replace(/\s*×\s*/g, "×");

      s = s.replace(/[–—]/g, "-");
      s = s.replace(/\s*-\s*/g, "-");

      s = s.replace(/[“”]/g, '"').replace(/[’]/g, "'");

      return s.toLowerCase().replace(/\s+/g, " ").trim();
    }

    function titlesMeaningfullyDifferent(pdfNorm, htmlNorm) {
      if (!pdfNorm || !htmlNorm) return true;
      if (pdfNorm === htmlNorm) return false;
      if (pdfNorm.includes(htmlNorm) || htmlNorm.includes(pdfNorm)) return false;

      const a = new Set(pdfNorm.split(/\s+/).filter(w => w.length > 2));
      const b = new Set(htmlNorm.split(/\s+/).filter(w => w.length > 2));
      const inter = [...a].filter(x => b.has(x)).length;
      const union = new Set([...a, ...b]).size;
      const jacc = union ? inter / union : 0;

      return jacc < 0.45;
    }

    function extractTitleFromPdfText(pdfText) {
      if (!pdfText) return null;
      let t = pdfText;

      // Use only page 1 chunk mostly
      const p1 = (t.split("===PAGE 2===")[0] || t);
      let s = cleanSpaces(p1);

      s = s.replace(/arXiv\s*:\s*\d{4}\.\d{5}v?\d*/ig, " ").trim();

      // stop at Abstract
      const absIdx = s.toLowerCase().indexOf("abstract");
      if (absIdx > 0) s = s.slice(0, absIdx);

      // remove obvious affiliation/email lines
      const lines = s.split("\n").map(x=>cleanSpaces(x)).filter(Boolean);
      const candidates = lines.filter(c =>
        c.length > 18 &&
        !/@/.test(c) &&
        !/university|institute|department|college|school|laboratory|ltd|inc\b/i.test(c) &&
        !/keywords\b/i.test(c)
      );

      // Prefer longer early lines
      candidates.sort((a,b)=>b.length-a.length);
      return candidates[0] || null;
    }

    function stripPdfTitleNoise(pdfTitle, htmlTitle){
      if (!pdfTitle) return pdfTitle;
      const p = cleanSpaces(pdfTitle);
      const h = cleanSpaces(htmlTitle || "");

      // Remove trailing author/date noise if PDF starts with HTML title
      if (h && p.toLowerCase().startsWith(h.toLowerCase())) {
        const tail = p.slice(h.length).trim();
        const monthRe = /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\b/i;
        const dateRe = /\b\d{1,2},\s*\d{4}\b|\b\d{4}\b/;
        if (monthRe.test(tail) || dateRe.test(tail)) return h;
        if (tail.length <= 45) return h;
        return p;
      }
      // Remove last "Name Name 2025" patterns
      return p.replace(/\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,3}\s+(?:\b\d{4}\b)\s*$/g, "").trim();
    }

    // ===== Abstract / Keywords rules =====
    function stripEmails(s){
      return (s||"").replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g, "");
    }
    function stripTrailingMarkers(s){
      return (s||"").replace(/(\s*[∗*†‡✉]+\s*)+$/g, "").trim();
    }

    function extractAbstractFromAnyText(text){
      if(!text) return null;
      const t = text.replace(/\r/g, "\n");
      const m = t.match(/\bAbstract\b([\s\S]*?)(?:\bKeywords\b\s*:|\bKEYWORDS\b\s*:|\n\s*1\s+Introduction\b|\n\s*I\.\s*Introduction\b|\Z)/i);
      if(!m) return null;
      let abs = cleanSpaces(m[1]);
      abs = stripEmails(abs);
      abs = stripTrailingMarkers(abs);
      // Guard: too short = likely failed
      if (abs.length < 40) return null;
      return abs;
    }

    // KEYWORDS: ONLY accept a short “Keywords:” line (prevents grabbing intro)
    function extractKeywordsStrict(text){
      if(!text) return [];
      const t = text.replace(/\r/g, "\n");
      const m = t.match(/\bKeywords\b\s*:\s*([^\n]{1,260})/i); // same line max 260 chars
      if(!m) return [];
      const line = cleanSpaces(m[1]);
      // If it looks like it continues into long prose, reject
      if (line.length > 220) return [];
      const parts = line.split(/,|;|\u2022|\u00B7/).map(x => x.trim()).filter(Boolean);
      // reject if any token is massive (signals prose)
      if (parts.some(p => p.length > 80)) return [];
      return parts.filter(k => k.length <= 140);
    }

    function extractAbstractFromHtml(htmlText){
      const metaDesc = (htmlText || "").match(/<meta[^>]+name=["']description["'][^>]+content=["']([^"']+)["']/i);
      if (metaDesc) return stripTrailingMarkers(stripEmails(cleanSpaces(metaDesc[1])));

      // very basic HTML-strip fallback
      const t = (htmlText || "");
      const m = t.match(/>Abstract<([\s\S]*?)(?:>Subjects<|>Comments<|>Journal reference<|>DOI<|<\/section>|<\/div>)/i);
      if (m){
        const tmp = m[1].replace(/<[^>]+>/g, " ");
        const abs = stripTrailingMarkers(stripEmails(cleanSpaces(tmp)));
        return abs.length >= 40 ? abs : null;
      }
      return null;
    }

    function extractKeywordsFromHtml(htmlText){
      const metaKw = (htmlText || "").match(/<meta[^>]+name=["']keywords["'][^>]+content=["']([^"']+)["']/i);
      if (metaKw){
        return metaKw[1].split(/,|;/).map(s=>cleanSpaces(s)).filter(Boolean);
      }
      return [];
    }

    // ===== Authors/Affils from API (best effort) =====
    function parseApiAuthorsAffils(apiXmlText){
      try{
        const doc = new DOMParser().parseFromString(apiXmlText, "application/xml");

        const authorNodes = [
          ...doc.querySelectorAll("authors > author"),
          ...doc.querySelectorAll("author"),
          ...doc.querySelectorAll("contrib-group contrib"),
        ];

        const authors = [];
        for (const n of authorNodes){
          const name =
            cleanSpaces(n.querySelector("name")?.textContent) ||
            cleanSpaces([
              n.querySelector("given-name, given-names")?.textContent,
              n.querySelector("surname")?.textContent
            ].filter(Boolean).join(" ")) ||
            cleanSpaces(n.textContent);

          if (!name) continue;
          if (name.length < 3) continue;
          if (/abstract|keywords|arxiv|http/i.test(name)) continue;
          if (!authors.includes(name)) authors.push(name);
        }

        const affNodes = [
          ...doc.querySelectorAll("affiliations > affiliation"),
          ...doc.querySelectorAll("affiliation"),
          ...doc.querySelectorAll("aff"),
        ];

        const affiliations = [];
        for (const a of affNodes){
          const txt = cleanSpaces(a.textContent);
          if (!txt) continue;
          if (txt.length < 6) continue;
          if (txt.length > 600) continue;
          if (!affiliations.includes(txt)) affiliations.push(txt);
        }

        return { ok:true, authors, affiliations };
      } catch(e){
        return { ok:false, authors:[], affiliations:[], error: String(e?.message || e) };
      }
    }

    // ===== OCR: render PDF page -> worker OCR (early stop when arXiv found) =====
    async function renderPdfPageToDataUrl(pdfBytes, pageNum, scale=2.0){
      configurePdfWorker();
      const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
      const pdf = await loadingTask.promise;

      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({ scale });

      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");
      c.width = Math.floor(viewport.width);
      c.height = Math.floor(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;
      return c.toDataURL("image/png");
    }

    async function ocrPages(pdfBytes, pages){
      const worker = await getOcrWorker();
      let all = "";
      const started = performance.now();

      for (const p of pages){
        appendLog(`⏳ OCR render page ${p}...`);
        const dataUrl = await renderPdfPageToDataUrl(pdfBytes, p, 2.0);

        appendLog(`⏳ OCR read page ${p}...`);
        const res = await worker.recognize(dataUrl);
        const txt = cleanSpaces(res?.data?.text || "");
        all += "\n" + txt;

        // EARLY STOP if arXiv found
        const found = extractArxivIdFromText(all);
        if (found?.id){
          const tookMs = Math.round(performance.now() - started);
          return { text: cleanSpaces(all), tookMs, early:true };
        }
      }

      const tookMs = Math.round(performance.now() - started);
      return { text: cleanSpaces(all), tookMs, early:false };
    }

    // ===== XML generation =====
    function makeAuthorXml(authorName, seq){
      const parts = cleanSpaces(authorName).split(" ").filter(Boolean);
      const surname = parts.length ? parts[parts.length-1] : authorName;
      const given = parts.length > 1 ? parts.slice(0, -1).join(" ") : "";
      const initials = given ? given.split(/\s+/).map(w => w[0].toUpperCase() + ".").join("") : "";

      return `
<author seq="${seq}">
  ${initials ? `<ce:initials>${escapeXml(initials)}</ce:initials>` : ``}
  <ce:surname>${escapeXml(surname)}</ce:surname>
  ${given ? `<ce:given-name>${escapeXml(given)}</ce:given-name>` : ``}
</author>`.trim();
    }

    function makeAffXml(affText){
      return `
<affiliation>
  <ce:source-text>${escapeXml(affText)}</ce:source-text>
</affiliation>`.trim();
    }

    function downloadTextFile(filename, content, mime){
      const blob = new Blob([content], { type: mime || "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 500);
    }

    function generateXML(){
      const id = verified.arxivId || "unknown";
      const v = verified.version || "";
      const idFull = `${id}${v}`;

      const title = verified.title || "";
      const abs = verified.abstract || "";
      const kws = verified.keywords || [];
      const authors = verified.authors || [];
      const affs = verified.affiliations || [];

      const authorXml = authors.map((a,i)=>makeAuthorXml(a, i+1)).join("\n");
      const affXml = affs.length ? affs.map(a => makeAffXml(a)).join("\n") : "";
      const kwXml = kws.length ? kws.map(k => `<author-keyword>${escapeXml(k)}</author-keyword>`).join("\n") : "";
      const now = new Date().toISOString();

      const xml = `<?xml version="1.0" encoding="UTF-8"?>
<units xmlns="http://www.elsevier.com/xml/ani/ani" xmlns:ce="http://www.elsevier.com/xml/ani/common">
  <unit type="ARTICLE">
    <unit-info>
      <unit-id>1</unit-id>
      <order-id>unknown</order-id>
      <parcel-id>none</parcel-id>
      <supplier-id>4</supplier-id>
      <timestamp>${now}</timestamp>
    </unit-info>

    <unit-content>
      <bibrecord>
        <item-info>
          <status state="new"/>
          <itemidlist>
            <itemid idtype="ARXIV">${escapeXml(idFull)}</itemid>
          </itemidlist>
        </item-info>

        <head>
          <citation-info>
            <citation-type code="ar"/>
            <citation-language xml:lang="ENG"/>
            <abstract-language xml:lang="ENG"/>
            ${kwXml ? `<author-keywords>\n${kwXml}\n</author-keywords>` : ``}
          </citation-info>

          <citation-title>
            <titletext xml:lang="ENG" original="y">${escapeXml(title)}</titletext>
          </citation-title>

          ${authors.length ? `<author-group seq="1">
${authorXml}
${affXml}
</author-group>` : ``}

          ${abs ? `<abstracts>
  <abstract original="y" xml:lang="ENG">
    <ce:para>${escapeXml(abs)}</ce:para>
  </abstract>
</abstracts>` : ``}

          <source srcid="???"/>
        </head>

        <tail/>
      </bibrecord>
    </unit-content>
  </unit>
</units>`;

      downloadTextFile(`arXiv_${idFull}.xml`, xml, "application/xml");
    }

    function validateXML(){
      alert("Schema validation comes next. (We’ll add XSD validation after XML output is stable.)");
    }

    async function runPipeline(){
      const runBtn = $("runBtn");
      runBtn.disabled = true;

      try{
        const file = $("zipInput").files[0];
        if (!file) { alert("Upload a ZIP first"); return; }

        resetGateCards();
        $("output").textContent = "ZIP loaded.\n";
        appendLog("Running gates...");

        Object.assign(verified, {
          arxivId:null, version:null, confirmed:false, title:null, abstract:null,
          keywords:[], authors:[], affiliations:[], notes:[], sources:{}
        });
        renderVerifiedInfo();

        const zip = await JSZip.loadAsync(file);
        state.zip = zip;

        const list = $("fileList");
        list.innerHTML = "";
        Object.keys(zip.files).forEach(f => {
          const li = document.createElement("li");
          li.textContent = f;
          list.appendChild(li);
        });

        // Gate 0 — presence
        state.files.api = findFile(zip, /_Api\.xml$/i);
        state.files.html = findFile(zip, /\.html$/i);
        state.files.scrape = findFile(zip, /_Scrapping\.xml$/i);
        state.files.pdf = findFile(zip, /\.pdf$/i);

        const missing = [];
        if (!state.files.api) missing.push("API XML (_Api.xml)");
        if (!state.files.html) missing.push("HTML (.html)");
        if (!state.files.scrape) missing.push("Scraping XML (_Scrapping.xml)");
        if (!state.files.pdf) missing.push("PDF (.pdf)");

        if (missing.length){
          addGateCard({ name:"Gate 0 — Support Docs Present", status:"FAIL", bodyLines:["Missing:", ...missing.map(m=>"✖ "+m)] });
          $("viewerStatus").textContent = "Viewer not loaded: missing required support docs.";
          return;
        }

        addGateCard({
          name: "Gate 0 — Support Docs Present",
          status: "PASS",
          bodyLines: ["✔ PDF present", "✔ HTML present", "✔ API XML present", "✔ Scrape XML present"]
        });

        appendLog("✔ Gate 0 PASSED (all support docs present)");
        appendLog("⏳ Loading support docs into viewer...");

        cleanupBlobUrls();

        state.blobs.pdfBytes   = await state.files.pdf.async("uint8array");
        state.htmlText         = await state.files.html.async("string");
        state.blobs.apiText    = await state.files.api.async("string");
        state.blobs.scrapeText = await state.files.scrape.async("string");

        const htmlBlob = new Blob([state.htmlText], { type:"text/html;charset=utf-8" });
        state.blobs.htmlUrl = URL.createObjectURL(htmlBlob);
        $("htmlFrame").src = state.blobs.htmlUrl;

        $("apiPane").textContent = state.blobs.apiText;
        $("scrapePane").textContent = state.blobs.scrapeText;

        await loadPdfViewer(state.blobs.pdfBytes);

        $("viewerStatus").textContent = "Support docs loaded (PDF.js/HTML/XML tabs ready).";
        appendLog("✔ Viewer loaded (PDF.js + HTML/XML)");

        $("openPdfBtn").disabled = false;

        // Extract from non-PDF sources
        const api = extractFromApiXml(state.blobs.apiText);
        const html = extractFromHtml(state.htmlText);
        const scrape = extractVersionFromScrapeXml(state.blobs.scrapeText);

        // Gate 0.5 — PDF trust STRICT (readable text OR OCR finds arXiv)
        const forceOcr = $("forceOcr").checked;
        const ocrPagesN = Math.max(1, Math.min(6, parseInt($("ocrPages").value || "3", 10)));

        appendLog(`⏳ Reading PDF text (pages 1–${ocrPagesN})...`);
        let pdf = { id:null, version:null };
        let pdfText = "";
        let pdfTrusted = false;
        let pdfTrustedVia = "none";
        let r = {charCount:0, wordCount:0, uniqueCharRatio:0, looksGarbage:false, readable:false};

        let ocrUsed = false;
        let ocrText = "";
        let ocrTookMs = 0;
        let ocrEarly = false;

        try{
          pdfText = await extractPdfTextStructured(state.blobs.pdfBytes, ocrPagesN);
          r = assessPdfReadability(pdfText);

          // text route
          if (!forceOcr && r.readable){
            const found = extractArxivIdFromText(pdfText);
            if (found?.id){
              pdf = found;
              pdfTrusted = true;
              pdfTrustedVia = "text";
              appendLog(`✔ PDF text found arXiv: ${pdf.id}${pdf.version || ""}`);
            }
          }

          // OCR route (forced OR text unreadable OR no arXiv found)
          if (forceOcr || !pdfTrusted){
            ocrUsed = true;
            appendLog(`⚠ OCR ${forceOcr ? "forced" : "needed"} → scanning pages 1–${ocrPagesN}...`);
            const pages = Array.from({length: ocrPagesN}, (_,i)=>i+1);
            const ocrRes = await ocrPages(state.blobs.pdfBytes, pages);
            ocrText = ocrRes.text || "";
            ocrTookMs = ocrRes.tookMs;
            ocrEarly = !!ocrRes.early;

            const foundOcr = extractArxivIdFromText(ocrText);
            if (foundOcr?.id){
              pdf = foundOcr;
              pdfTrusted = true;
              pdfTrustedVia = "ocr";
              appendLog(`✔ OCR found arXiv: ${pdf.id}${pdf.version || ""} (OCR ${ocrTookMs}ms${ocrEarly ? ", early stop" : ""})`);
            } else {
              appendLog(`⚠ OCR did NOT find arXiv on pages 1–${ocrPagesN} (OCR ${ocrTookMs}ms)`);
            }
          }
        } catch(e){
          appendLog("ERROR in PDF/OCR step: " + (e?.message || e));
          pdfTrusted = false;
        }

        addGateCard({
          name: "Gate 0.5 — PDF Trust Check (STRICT + OCR)",
          status: pdfTrusted ? "PASS" : "WARN",
          bodyLines: [
            `text chars: ${r.charCount}`,
            `text words: ${r.wordCount}`,
            `uniqueCharRatio: ${r.uniqueCharRatio}`,
            r.looksGarbage ? "⚠ text looks garbled" : "✔ text looks normal (if present)",
            ocrUsed ? `OCR attempted: yes (${ocrTookMs}ms${ocrEarly ? ", early stop" : ""})` : "OCR attempted: no",
            pdfTrusted ? `✔ PDF trusted via ${pdfTrustedVia} (arXiv detected)` : "⚠ PDF not trusted → fallback still requires cross-source agreement"
          ],
          verifiedLine: pdfTrusted ? `✔ PDF TRUSTED (${pdfTrustedVia.toUpperCase()})` : "⚠ PDF NOT TRUSTED"
        });

        // Gate 1 — ID/version confirmation
        const g1 = gate1Confirm({ pdf, html, scrape, api, pdfTrusted });

        addGateCard({
          name: "Gate 1 — arXiv ID & Version (Comprehensive Confirm)",
          status: g1.ok ? (g1.warnings.length ? "WARN" : "PASS") : "FAIL",
          bodyLines: [
            `PDF:    id=${pdf?.id || "?"}, version=${pdf?.version || "(none)"}`,
            `API:    id=${api?.id || "?"}, version=${api?.version || "(none)"}`,
            `HTML:   id=${html?.id || "?"}, version=${html?.version || "(none)"}`,
            `Scrape: id=${scrape?.id || "?"}, version=${scrape?.version || "(none)"}`,
            `Mode: ${g1.mode}`,
            ...g1.notes.map(n => "Note: " + n),
            ...g1.warnings.map(w => "WARN: " + w),
            ...(g1.ok ? [] : g1.problems.map(p => "✖ " + p))
          ],
          verifiedLine: g1.ok ? `✔ Gate 1 PASSED → arXiv:${g1.chosenId}${g1.chosenV || ""}` : "✖ HOLD: ID/version not confirmed"
        });

        if (!g1.ok){
          setVerified({
            arxivId: g1.chosenId || null,
            version: g1.chosenV || null,
            confirmed: false,
            notes: [...(g1.problems||[]), ...(g1.warnings||[])]
          });
          return;
        }

        setVerified({
          arxivId: g1.chosenId || null,
          version: g1.chosenV || null,
          confirmed: true,
          notes: [
            `Gate 1 mode: ${g1.mode}`,
            ...(g1.warnings || [])
          ],
          sources: { pdf, api, html, scrape }
        });

        // Gate 2 — Title
        const htmlTitle = extractTitleFromHtml(state.htmlText);

        let rawPdfTitle = null;
        let pdfTitle = null;
        const titleTextSource = (pdfTrustedVia === "text") ? pdfText : (pdfTrustedVia === "ocr" ? ocrText : "");

        if (pdfTrusted && titleTextSource){
          rawPdfTitle = extractTitleFromPdfText(titleTextSource);
          pdfTitle = stripPdfTitleNoise(rawPdfTitle, htmlTitle);
        }

        const pdfNorm = normalizeTitleForCompare(pdfTitle || "");
        const htmlNorm = normalizeTitleForCompare(htmlTitle || "");

        let selectedTitle = null;
        let titleNote = "";

        if (!pdfTrusted){
          titleNote = "⚠ PDF not trusted → SELECT HTML title";
          selectedTitle = htmlTitle || null;
        } else if (pdfNorm && htmlNorm && pdfNorm === htmlNorm) {
          titleNote = "✔ Titles match after normalization";
          selectedTitle = pdfTitle || htmlTitle;
        } else {
          const meaningDiff = titlesMeaningfullyDifferent(pdfNorm, htmlNorm);
          if (meaningDiff){
            // your rule: if meaning differs, always capture HTML even if PDF longer
            titleNote = "⚠ Titles differ in meaning → per rule SELECT HTML title";
            selectedTitle = htmlTitle || pdfTitle;
          } else {
            titleNote = "⚠ Meaning same → per rule SELECT more complete (minus author/date noise)";
            selectedTitle = (pdfTitle && pdfTitle.length >= (htmlTitle||"").length) ? pdfTitle : htmlTitle;
          }
        }

        addGateCard({
          name: "Gate 2 — Title Decision (Rules Applied)",
          status: selectedTitle ? "PASS" : "FAIL",
          bodyLines: [
            `PDF title (clean): ${pdfTitle || "(not used)"}`,
            `HTML title:       ${htmlTitle || "?"}`,
            titleNote,
            `Selected:         ${selectedTitle || "(none)"}`
          ],
          verifiedLine: selectedTitle ? "✔ Gate 2 PASSED" : "✖ Gate 2 FAILED"
        });

        setVerified({ title: selectedTitle || null });

        // Gate 3 — Abstract + Keywords (Text → OCR → HTML fallback)
        let abs = null;
        let kws = [];

        // Prefer PDF text if trusted and readable, else OCR if we ran it
        if (pdfTrustedVia === "text") {
          abs = extractAbstractFromAnyText(pdfText);
          kws = extractKeywordsStrict(pdfText);
        }
        if (!abs && pdfTrustedVia === "ocr") {
          abs = extractAbstractFromAnyText(ocrText);
          kws = extractKeywordsStrict(ocrText);
        }

        // fallback HTML
        if (!abs) abs = extractAbstractFromHtml(state.htmlText) || null;
        if (!kws.length) kws = extractKeywordsFromHtml(state.htmlText) || [];

        abs = abs ? stripTrailingMarkers(stripEmails(cleanSpaces(abs))) : null;

        addGateCard({
          name: "Gate 3 — Abstract + Keywords (Fixed Keyword Guard)",
          status: (abs && kws.length) ? "PASS" : "WARN",
          bodyLines: [
            `Abstract: ${abs ? "captured" : "NOT found"}`,
            `Keywords: ${kws.length ? kws.join(", ") : "NOT found"}`
          ],
          verifiedLine: abs ? "✔ Abstract OK" : "⚠ Abstract needs stronger parsing/OCR"
        });

        setVerified({ abstract: abs || null, keywords: kws || [] });

        // Gate 4 — Authors + Affiliations (API)
        const apiAA = parseApiAuthorsAffils(state.blobs.apiText);

        addGateCard({
          name: "Gate 4 — Authors & Affiliations (API)",
          status: (apiAA.ok && apiAA.authors.length) ? "PASS" : "WARN",
          bodyLines: [
            `Authors: ${apiAA.authors.length}`,
            ...apiAA.authors.slice(0, 12).map(a => "• " + a),
            apiAA.authors.length > 12 ? "…(more)" : "",
            "",
            `Affiliations: ${apiAA.affiliations.length}`,
            ...apiAA.affiliations.slice(0, 8).map(a => "• " + a),
            apiAA.affiliations.length > 8 ? "…(more)" : ""
          ].filter(Boolean),
          verifiedLine: apiAA.authors.length ? "✔ API author order preserved" : "⚠ No authors found in API XML"
        });

        setVerified({
          authors: apiAA.authors || [],
          affiliations: apiAA.affiliations || []
        });

        appendLog("✔ Pipeline complete. Next: Generate XML → then schema validation.");

      } catch(e){
        appendLog("ERROR: " + (e?.message || e));
      } finally {
        $("runBtn").disabled = false;
        switchTab(state.currentTab);
      }
    }
  </script>
</body>
</html>
